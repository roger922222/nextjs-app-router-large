# Next.js App Router 性能优化策略 - 加载体验优化篇

## 概述

加载体验优化是提升用户满意度的关键因素。本文详细介绍基于 Next.js App Router 的渐进式加载、骨架屏、错误边界等优化策略，通过系统性的用户体验设计，实现感知性能的大幅提升。

## 渐进式加载策略

### 1. Suspense 与流式渲染

#### 基础实现
```typescript
// app/streaming/page.tsx - 当前实现
import { Suspense } from "react";

async function SlowBlock({ ms, label }: { ms: number; label: string }) {
  await new Promise((r) => setTimeout(r, ms));
  return (
    <section>
      <h3>{label}</h3>
      <p>我是一个慢速服务器组件，延迟 {ms / 1000}s 后才渲染。</p>
    </section>
  );
}

export default function StreamingPage() {
  return (
    <div>
      <h2>Suspense 与流式渲染</h2>
      <Suspense fallback={<section><h3>块 1 加载中...</h3></section>}>
        <SlowBlock ms={2000} label="块 1（2s）" />
      </Suspense>
      <Suspense fallback={<section><h3>块 2 加载中...</h3></section>}>
        <SlowBlock ms={4000} label="块 2（4s）" />
      </Suspense>
    </div>
  );
}
```

#### 高级渐进式加载
```typescript
// components/ProgressiveLoader.tsx
interface LoadingPhase {
  skeleton: React.ComponentType;
  partial: React.ComponentType<{ data: any }>;
  complete: React.ComponentType<{ data: any }>;
}

interface ProgressiveLoaderProps {
  phases: LoadingPhase;
  loadData: () => Promise<any>;
  priority?: 'high' | 'medium' | 'low';
  timeout?: number;
}

export function ProgressiveLoader({ 
  phases, 
  loadData,
  priority = 'medium',
  timeout = 30000
}: ProgressiveLoaderProps) {
  const [phase, setPhase] = useState<'skeleton' | 'partial' | 'complete' | 'error'>('skeleton');
  const [data, setData] = useState<any>(null);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    let cancelled = false;
    const timer = setTimeout(() => {
      if (phase === 'skeleton') {
        setPhase('error');
        setError(new Error('Loading timeout'));
      }
    }, timeout);
    
    loadDataWithPriority(loadData, priority)
      .then(result => {
        if (cancelled) return;
        
        clearTimeout(timer);
        
        // 阶段1: 骨架屏 -> 部分数据
        setPhase('partial');
        setData(result.slice(0, getInitialLoadSize(priority)));
        
        // 阶段2: 部分数据 -> 完整数据
        setTimeout(() => {
          if (!cancelled) {
            setPhase('complete');
            setData(result);
          }
        }, getStaggerDelay(priority));
      })
      .catch(err => {
        if (!cancelled) {
          clearTimeout(timer);
          setPhase('error');
          setError(err);
        }
      });
    
    return () => {
      cancelled = true;
      clearTimeout(timer);
    };
  }, [loadData, priority, timeout]);
  
  const { skeleton: Skeleton, partial: Partial, complete: Complete } = phases;
  
  if (phase === 'skeleton') return <Skeleton />;
  if (phase === 'error') return <ErrorFallback error={error} />;
  if (phase === 'partial') return <Partial data={data} />;
  return <Complete data={data} />;
}

function loadDataWithPriority<T>(
  loadFn: () => Promise<T>,
  priority: string
): Promise<T> {
  const priorityDelays = { high: 0, medium: 100, low: 300 };
  const delay = priorityDelays[priority as keyof typeof priorityDelays] || 100;
  
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      loadFn().then(resolve).catch(reject);
    }, delay);
  });
}

function getInitialLoadSize(priority: string): number {
  const sizes = { high: 10, medium: 5, low: 3 };
  return sizes[priority as keyof typeof sizes] || 5;
}

function getStaggerDelay(priority: string): number {
  const delays = { high: 200, medium: 500, low: 1000 };
  return delays[priority as keyof typeof delays] || 500;
}
```

### 2. 智能骨架屏系统

#### 动态骨架屏生成器
```typescript
// components/SkeletonGenerator.tsx
interface SkeletonConfig {
  type: 'text' | 'image' | 'card' | 'list';
  count?: number;
  animated?: boolean;
  width?: string;
  height?: string;
}

export function SkeletonGenerator({ 
  config,
  className = ""
}: { 
  config: SkeletonConfig | SkeletonConfig[];
  className?: string;
}) {
  const configs = Array.isArray(config) ? config : [config];
  
  return (
    <div className={`skeleton-container ${className}`}>
      {configs.map((cfg, index) => (
        <div key={index} className="skeleton-group">
          {Array.from({ length: cfg.count || 1 }).map((_, i) => (
            <SkeletonElement key={i} config={cfg} />
          ))}
        </div>
      ))}
    </div>
  );
}

function SkeletonElement({ config }: { config: SkeletonConfig }) {
  const baseClasses = [
    'skeleton',
    `skeleton--${config.type}`,
    config.animated !== false && 'skeleton--animated'
  ].filter(Boolean).join(' ');
  
  const style = {
    width: config.width || getDefaultWidth(config.type),
    height: config.height || getDefaultHeight(config.type),
  };
  
  return <div className={baseClasses} style={style} />;
}

function getDefaultWidth(type: string): string {
  switch (type) {
    case 'text': return '100%';
    case 'image': return '200px';
    case 'card': return '300px';
    case 'list': return '100%';
    default: return '100px';
  }
}

function getDefaultHeight(type: string): string {
  switch (type) {
    case 'text': return '20px';
    case 'image': return '150px';
    case 'card': return '200px';
    case 'list': return '60px';
    default: return '20px';
  }
}
```

#### CSS 动画骨架屏
```css
/* styles/skeleton.css */
.skeleton {
  background: linear-gradient(
    90deg,
    #f0f0f0 25%,
    #e0e0e0 50%,
    #f0f0f0 75%
  );
  background-size: 200% 100%;
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.skeleton--animated::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.4),
    transparent
  );
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

.skeleton--text {
  border-radius: 2px;
  margin: 8px 0;
}

.skeleton--image {
  border-radius: 8px;
}

.skeleton--card {
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.skeleton--list {
  border-radius: 4px;
  margin: 4px 0;
}
```

## 最佳实践建议

### 1. 加载优先级策略
- **高优先级**：核心内容、首屏数据
- **中优先级**：次要内容、用户交互元素
- **低优先级**：装饰性内容、统计数据

### 2. 骨架屏设计原则
- **保持一致性**：骨架屏结构与实际内容结构相似
- **动画适度**：避免过度动画影响性能
- **响应式**：适配不同屏幕尺寸

### 3. 错误处理策略
- **分级处理**：根据错误严重程度采取不同策略
- **自动重试**：对临时性错误进行自动重试
- **降级方案**：提供功能降级选项

通过这套加载体验优化策略，可以显著提升用户的感知性能，减少跳出率，提高用户满意度。