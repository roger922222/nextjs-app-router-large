# Next.js 性能优化专题

## 1. 性能优化基础概念

### Core Web Vitals 指标
- **LCP (Largest Contentful Paint)**: < 2.5s
- **FID (First Input Delay)**: < 100ms  
- **CLS (Cumulative Layout Shift)**: < 0.1
- **FCP (First Contentful Paint)**: < 1.8s
- **TTFB (Time to First Byte)**: < 800ms

### 性能优化层次
1. **网络层**: CDN、HTTP/2、压缩、缓存
2. **渲染层**: 关键路径优化、代码分割、懒加载
3. **运行时**: 内存管理、事件优化、状态管理

## 2. 图片优化策略

### Next.js Image 组件优化
```javascript
import Image from 'next/image'

export function OptimizedImage({ src, alt, priority = false }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={800}
      height={600}
      priority={priority}
      quality={85}
      placeholder="blur"
      sizes="(max-width: 768px) 100vw, 400px"
    />
  )
}
```

### 响应式图片实现
```javascript
export function ResponsiveImage({ src, alt, aspectRatio = "16:9" }) {
  const [width, height] = aspectRatio.split(':').map(Number)
  
  return (
    <div className="relative w-full" style={{ paddingBottom: `${(height / width) * 100}%` }}>
      <Image
        src={src}
        alt={alt}
        fill
        sizes="100vw"
        quality={85}
        placeholder="blur"
        className="absolute inset-0 object-cover"
      />
    </div>
  )
}
```

## 3. 代码分割和懒加载

### 动态导入实现
```javascript
import dynamic from 'next/dynamic'

// 基础动态导入
const HeavyComponent = dynamic(
  () => import('@/components/HeavyComponent'),
  {
    loading: () => <div>Loading...</div>,
    ssr: false
  }
)

// 带骨架屏的动态导入
const ChartComponent = dynamic(
  () => import('@/components/ChartComponent'),
  {
    loading: () => <ChartSkeleton />,
    ssr: true
  }
)
```

### 路由级别的代码分割
```javascript
// app/dashboard/page.tsx
import { Suspense } from 'react'

const UserStats = dynamic(() => import('@/components/UserStats'))
const RevenueChart = dynamic(() => import('@/components/RevenueChart'))

export default function DashboardPage() {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <Suspense fallback={<StatsSkeleton />}>
        <UserStats />
      </Suspense>
      
      <Suspense fallback={<ChartSkeleton />}>
        <RevenueChart />
      </Suspense>
    </div>
  )
}
```

## 4. 缓存策略优化

### 三层缓存架构

**1. 请求级缓存（内存）**
```javascript
export class RequestCache {
  private cache = new Map<string, { value: any; expires: number }>()
  
  async get<T>(key: string): Promise<T | null> {
    const item = this.cache.get(key)
    if (!item) return null
    
    if (Date.now() > item.expires) {
      this.cache.delete(key)
      return null
    }
    
    return item.value
  }
  
  async set<T>(key: string, value: T, ttl = 60000): Promise<void> {
    this.cache.set(key, {
      value,
      expires: Date.now() + ttl
    })
  }
}
```

**2. 数据级缓存（fetch缓存）**
```javascript
const data = await fetch('https://api.example.com/data', {
  next: {
    revalidate: 60, // 60秒重新验证
    tags: ['products'] // 标签化缓存
  }
})

// 手动重新验证
import { revalidateTag } from 'next/cache'
revalidateTag('products')
```

**3. 页面级缓存（CDN）**
```javascript
// 通过配置控制页面缓存
export const revalidate = 3600 // 1小时

export default async function Page() {
  // 整个页面会被缓存1小时
  return <div>Static content</div>
}
```

### 智能缓存策略
```javascript
export class SmartCache {
  async get<T>(
    key: string,
    fetcher: () => Promise<T>,
    config: { ttl: number }
  ): Promise<T> {
    // 检查缓存
    const cached = await this.getCached<T>(key)
    if (cached) {
      return cached
    }
    
    // 获取新数据
    const freshData = await fetcher()
    await this.set(key, freshData, config.ttl)
    
    return freshData
  }
}
```

## 5. 网络优化

### 请求优化
```javascript
export class OptimizedAPIClient {
  private pendingRequests = new Map<string, Promise<any>>()
  
  async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    // 请求去重
    const requestKey = this.generateRequestKey(endpoint, options)
    if (this.pendingRequests.has(requestKey)) {
      return this.pendingRequests.get(requestKey)!
    }
    
    const requestPromise = this.executeWithRetry(endpoint, options)
    this.pendingRequests.set(requestKey, requestPromise)
    
    try {
      const result = await requestPromise
      this.pendingRequests.delete(requestKey)
      return result
    } catch (error) {
      this.pendingRequests.delete(requestKey)
      throw error
    }
  }
  
  private async executeWithRetry(
    endpoint: string,
    options: RequestInit,
    attempt = 1
  ): Promise<any> {
    try {
      const response = await fetch(endpoint, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      })
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      return response.json()
      
    } catch (error) {
      if (attempt >= 3) {
        throw error
      }
      
      // 指数退避重试
      const delay = 1000 * Math.pow(2, attempt - 1)
      await new Promise(resolve => setTimeout(resolve, delay))
      
      return this.executeWithRetry(endpoint, options, attempt + 1)
    }
  }
}
```

### 批量请求优化
```javascript
export class BatchRequestManager {
  private queue: Array<any> = []
  private processing = false
  private batchSize = 10
  private batchDelay = 50
  
  async add<T>(endpoint: string, options?: RequestInit): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push({
        id: Math.random().toString(36).substr(2, 9),
        endpoint,
        options,
        resolve,
        reject
      })
      
      if (!this.processing) {
        this.scheduleBatchProcessing()
      }
    })
  }
  
  private scheduleBatchProcessing() {
    this.processing = true
    
    setTimeout(async () => {
      await this.processBatch()
      
      if (this.queue.length > 0) {
        this.scheduleBatchProcessing()
      } else {
        this.processing = false
      }
    }, this.batchDelay)
  }
  
  private async processBatch() {
    const batch = this.queue.splice(0, this.batchSize)
    
    // 按端点分组请求
    const groupedRequests = this.groupRequestsByEndpoint(batch)
    
    // 并行处理各组请求
    const promises = Object.entries(groupedRequests).map(
      ([endpoint, requests]) => this.processEndpointGroup(endpoint, requests)
    )
    
    await Promise.allSettled(promises)
  }
  
  private groupRequestsByEndpoint(requests: any[]) {
    return requests.reduce((groups, request) => {
      const key = request.endpoint
      if (!groups[key]) {
        groups[key] = []
      }
      groups[key].push(request)
      return groups
    }, {})
  }
}
```

## 6. 渲染优化

### 关键渲染路径优化
```javascript
// app/layout.tsx
import { Inter } from 'next/font/google'

const inter = Inter({ 
  subsets: ['latin'],
  display: 'swap', // 避免FOIT
  preload: true
})

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={inter.className}>
      <head>
        {/* 预加载关键资源 */}
        <link rel="preload" href="/critical.css" as="style" />
        <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossOrigin="anonymous" />
        
        {/* DNS预解析 */}
        <link rel="dns-prefetch" href="https://api.example.com" />
        <link rel="preconnect" href="https://api.example.com" crossOrigin="anonymous" />
      </head>
      <body>{children}</body>
    </html>
  )
}
```

### 流式渲染优化
```javascript
// app/page.tsx
import { Suspense } from 'react'

export default function Page() {
  return (
    <div>
      {/* 关键内容优先渲染 */}
      <header>
        <h1>My Store</h1>
        <Suspense fallback={<div>Loading cart...</div>}>
          <Cart />
        </Suspense>
      </header>
      
      {/* 非关键内容流式渲染 */}
      <main>
        <Suspense fallback={<ProductListSkeleton />}>
          <ProductList />
        </Suspense>
        
        <Suspense fallback={<RecommendationsSkeleton />}>
          <Recommendations />
        </Suspense>
      </main>
    </div>
  )
}
```

## 7. 性能监控和分析

### 性能监控实现
```javascript
// lib/performance/monitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()
  
  measure<T>(name: string, fn: () => T): T {
    const start = performance.now()
    
    try {
      const result = fn()
      
      if (result instanceof Promise) {
        return result.finally(() => {
          this.recordMetric(name, performance.now() - start)
        }) as T
      } else {
        this.recordMetric(name, performance.now() - start)
        return result
      }
    } catch (error) {
      this.recordMetric(name, performance.now() - start)
      throw error
    }
  }
  
  private recordMetric(name: string, duration: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }
    
    this.metrics.get(name)!.push(duration)
    
    // 保持最近100个数据点
    const values = this.metrics.get(name)!
    if (values.length > 100) {
      values.shift()
    }
  }
  
  getStats(name: string) {
    const values = this.metrics.get(name) || []
    if (values.length === 0) return null
    
    const sorted = [...values].sort((a, b) => a - b)
    const count = values.length
    const sum = values.reduce((a, b) => a + b, 0)
    
    return {
      count,
      avg: sum / count,
      min: sorted[0],
      max: sorted[count - 1],
      p50: sorted[Math.floor(count * 0.5)],
      p95: sorted[Math.floor(count * 0.95)],
      p99: sorted[Math.floor(count * 0.99)]
    }
  }
}
```

### 性能分析工具
```javascript
// lib/performance/analyzer.ts
export class PerformanceAnalyzer {
  analyzeBundleSize(modules: ModuleInfo[]) {
    const analysis = {
      totalSize: 0,
      byFramework: {} as Record<string, number>,
      byType: {} as Record<string, number>,
      largeModules: [] as ModuleInfo[]
    }
    
    modules.forEach(module => {
      analysis.totalSize += module.size
      
      // 按框架分类
      if (module.name.includes('react')) {
        analysis.byFramework.react = (analysis.byFramework.react || 0) + module.size
      } else if (module.name.includes('next')) {
        analysis.byFramework.next = (analysis.byFramework.next || 0) + module.size
      }
      
      // 大模块识别
      if (module.size > 100 * 1024) { // 100KB
        analysis.largeModules.push(module)
      }
    })
    
    return analysis
  }
}
```

## 8. 性能优化最佳实践

### 优化清单
1. ✅ 使用 Next.js Image 组件优化图片
2. ✅ 实现代码分割和懒加载
3. ✅ 配置多层缓存策略
4. ✅ 优化网络请求（去重、批量、重试）
5. ✅ 使用流式渲染提升首屏体验
6. ✅ 监控和分析性能指标
7. ✅ 实施渐进式增强策略
8. ✅ 优化关键渲染路径

### 性能优化建议
1. **优先处理关键渲染路径**：内联关键CSS、预加载关键资源
2. **合理使用缓存**：根据数据更新频率选择合适的缓存策略
3. **优化图片加载**：使用适当的格式、尺寸和质量设置
4. **实施代码分割**：按路由和组件粒度进行代码分割
5. **监控性能指标**：持续监控Core Web Vitals指标
6. **定期性能审计**：使用Lighthouse等工具进行性能审计

通过系统性地实施这些优化策略，可以显著提升Next.js应用的性能表现。
