# Next.js 常见错误和解决方案

## 1. 构建和开发错误

### 1.1 Module not found 错误

**错误示例：**
```
Module not found: Can't resolve '@/components/Button'
```

**解决方案：**
1. 检查文件路径是否正确
2. 确保文件名大小写匹配（Linux系统区分大小写）
3. 检查 tsconfig.json 中的 paths 配置

```json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

### 1.2 图片导入错误

**错误示例：**
```
Module not found: Can't resolve './image.png'
```

**解决方案：**
```typescript
// 正确方式
import Image from 'next/image'
import profilePic from './me.png'

export default function Profile() {
  return (
    <Image
      src={profilePic}
      alt="Picture of the author"
    />
  )
}
```

### 1.3 styled-jsx 错误

**错误示例：**
```
'client-only' cannot be imported from a Server Component module
```

**解决方案：**
- 移除 styled-jsx，改用 CSS Modules 或 Tailwind CSS
- 确保样式文件在客户端组件中使用

## 2. 路由相关错误

### 2.1 404 页面错误

**常见原因：**
1. 文件路径不正确
2. 动态路由参数未正确处理

**解决方案：**
```javascript
// app/products/[id]/page.tsx
export default function ProductPage({ params }: { params: { id: string } }) {
  // 正确使用 params
  const productId = params.id
  
  return <div>Product ID: {productId}</div>
}
```

### 2.2 动态路由 generateStaticParams 错误

**错误示例：**
```
Error: Page "products/[id]" is missing "generateStaticParams()"
```

**解决方案：**
```javascript
export async function generateStaticParams() {
  const products = await getProducts()
  
  return products.map((product) => ({
    id: product.id.toString(),
  }))
}
```

### 2.3 路由组错误

**错误示例：**
```
Error: You cannot define a route with the same specificity as a parallel slot
```

**解决方案：**
- 确保路由组名称不冲突
- 正确使用 @slot 语法

## 3. 数据获取错误

### 3.1 fetch 错误

**错误示例：**
```
TypeError: Failed to parse URL from [object Promise]/api/data
```

**解决方案：**
```javascript
// 错误
const baseUrl = getBaseUrl() // 返回 Promise
const response = await fetch(`${baseUrl}/api/data`)

// 正确
const baseUrl = await getBaseUrl() // 等待 Promise 解析
const response = await fetch(`${baseUrl}/api/data`)
```

### 3.2 服务器组件中的客户端代码

**错误示例：**
```
You're importing a component that needs useState. It only works in a Client Component
```

**解决方案：**
```javascript
// 添加 "use client" 指令
'use client'

import { useState } from 'react'

export default function ClientComponent() {
  const [count, setCount] = useState(0)
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  )
}
```

### 3.3 缓存和重新验证错误

**错误示例：**
```
Error: revalidate is not valid in getStaticProps
```

**解决方案：**
```javascript
// Pages Router
export async function getStaticProps() {
  return {
    props: {},
    revalidate: 60 // 正确使用 revalidate
  }
}

// App Router
export const revalidate = 60 // 在页面级别使用
```

## 4. 性能相关错误

### 4.1 大图片导致的性能问题

**问题：**
- 未优化的图片导致页面加载缓慢
- 没有使用 Next.js Image 组件

**解决方案：**
```javascript
import Image from 'next/image'

export default function OptimizedImage({ src, alt }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={800}
      height={600}
      priority // 关键图片优先加载
      placeholder="blur"
      blurDataURL={generateBlurDataURL(src)}
    />
  )
}
```

### 4.2 内存泄漏

**常见原因：**
1. 事件监听器未正确清理
2. 定时器未清除
3. 异步请求未取消

**解决方案：**
```javascript
'use client'

import { useEffect, useRef } from 'react'

export default function Component() {
  const intervalRef = useRef<NodeJS.Timeout>()
  const abortControllerRef = useRef<AbortController>()
  
  useEffect(() => {
    // 设置定时器
    intervalRef.current = setInterval(() => {
      // 定时任务
    }, 1000)
    
    // 异步请求
    abortControllerRef.current = new AbortController()
    fetch('/api/data', {
      signal: abortControllerRef.current.signal
    })
    
    // 清理函数
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
      }
      
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
  }, [])
  
  return <div>Component</div>
}
```

### 4.3 无限重新渲染

**问题：**
```javascript
// 错误：每次渲染都会创建新对象
function Component() {
  const [items, setItems] = useState([])
  
  useEffect(() => {
    fetchData({ filters: {} }) // 每次都会重新执行
  }, [{ filters: {} }]) // 依赖项每次都会变化
}
```

**解决方案：**
```javascript
// 正确：使用 useMemo 或提取到组件外部
const defaultFilters = useMemo(() => ({ filters: {} }), [])

useEffect(() => {
  fetchData(defaultFilters)
}, [defaultFilters])
```

## 5. 部署相关错误

### 5.1 环境变量错误

**错误示例：**
```
Error: Environment variable NEXT_PUBLIC_API_URL is not defined
```

**解决方案：**
```bash
# .env.local
NEXT_PUBLIC_API_URL=https://api.example.com
DATABASE_URL=postgresql://localhost:5432/mydb
```

**注意：**
- 客户端使用的变量需要 `NEXT_PUBLIC_` 前缀
- 服务器端变量不需要此前缀

### 5.2 构建时错误

**错误示例：**
```
Error: Build optimization failed
```

**常见原因：**
1. 循环依赖
2. 过大的包大小
3. 内存不足

**解决方案：**
```javascript
// next.config.js
module.exports = {
  // 分析包大小
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false
      }
    }
    
    return config
  },
  
  // 增加内存限制
  experimental: {
    workerThreads: false,
    cpus: 2
  }
}
```

### 5.3 服务器端渲染错误

**错误示例：**
```
Error: Hydration failed because the initial UI does not match what was rendered on the server
```

**常见原因：**
1. 客户端和服务器渲染结果不一致
2. 使用了浏览器特有的 API
3. 时间或随机数导致的不一致

**解决方案：**
```javascript
'use client'

import { useEffect, useState } from 'react'

export default function Component() {
  const [isClient, setIsClient] = useState(false)
  
  useEffect(() => {
    setIsClient(true)
  }, [])
  
  // 只在客户端渲染的内容
  if (!isClient) {
    return null // 或加载状态
  }
  
  return (
    <div>
      {new Date().toLocaleString()} {/* 时间相关的内容 */}
    </div>
  )
}
```

## 6. 第三方库集成错误

### 6.1 CSS-in-JS 库错误

**问题：**
- Styled-components、Emotion 等在服务器端渲染时出现问题

**解决方案：**
```javascript
// app/registry.tsx
'use client'

import { useServerInsertedHTML } from 'next/navigation'
import { StyleRegistry, createStyleRegistry } from 'styled-jsx'
import { useState } from 'react'

export function StyledComponentsRegistry({ children }) {
  const [jsxStyleRegistry] = useState(() => createStyleRegistry())
  
  useServerInsertedHTML(() => {
    const styles = jsxStyleRegistry.styles()
    jsxStyleRegistry.flush()
    return <>{styles}</>
  })
  
  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>
}
```

### 6.2 图表库错误

**问题：**
- Chart.js、D3.js 等库在服务器端无法使用

**解决方案：**
```javascript
// components/Chart.tsx
'use client'

import dynamic from 'next/dynamic'

const Chart = dynamic(
  () => import('chart.js/auto'),
  {
    ssr: false, // 禁用服务器端渲染
    loading: () => <div>Loading chart...</div>
  }
)

export default function ChartComponent({ data }) {
  return <Chart data={data} />
}
```

## 7. 调试技巧

### 7.1 开发工具

**Chrome DevTools：**
- Network 面板：检查请求和响应
- Performance 面板：分析性能瓶颈
- Console 面板：查看错误和警告

**Next.js 特定工具：**
```bash
# 分析包大小
npm run analyze

# 开发模式详细日志
DEBUG=next:* npm run dev

# 检查 TypeScript 错误
npm run type-check
```

### 7.2 日志和监控

```javascript
// lib/logger.ts
export const logger = {
  info: (message: string, data?: any) => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[INFO] ${message}`, data)
    }
  },
  
  error: (message: string, error?: Error, data?: any) => {
    console.error(`[ERROR] ${message}`, error, data)
    
    // 发送到监控服务
    if (process.env.NODE_ENV === 'production') {
      // 发送到 Sentry、LogRocket 等
    }
  }
}
```

### 7.3 性能调试

```javascript
// app/debug/page.tsx
'use client'

import { useEffect } from 'react'

export default function DebugPage() {
  useEffect(() => {
    // 性能测量
    const measurePerformance = () => {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          console.log(`${entry.name}: ${entry.duration}ms`)
        }
      })
      
      observer.observe({ entryTypes: ['measure', 'navigation'] })
      
      // 测量特定操作
      performance.mark('start-operation')
      // ... 执行操作
      performance.mark('end-operation')
      performance.measure('operation', 'start-operation', 'end-operation')
    }
    
    measurePerformance()
  }, [])
  
  return (
    <div>
      <h1>Debug Page</h1>
      <button onClick={() => {
        console.log('Current state:', {
          userAgent: navigator.userAgent,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          connection: (navigator as any).connection
        })
      }}>
        Log Environment Info
      </button>
    </div>
  )
}
```

## 总结

### 错误预防最佳实践：

1. **代码审查**：定期进行代码审查，发现潜在问题
2. **类型检查**：使用 TypeScript 捕获类型错误
3. **单元测试**：编写全面的单元测试
4. **集成测试**：测试组件间的交互
5. **性能监控**：持续监控应用性能
6. **错误边界**：使用错误边界捕获和处理错误
7. **日志记录**：建立完善的日志系统

### 调试工具推荐：

1. **Next.js DevTools**：官方开发工具
2. **React DevTools**：React 组件调试
3. **Chrome DevTools**：浏览器调试工具
4. **Sentry**：错误监控和报告
5. **LogRocket**：用户会话回放
6. **WebPageTest**：性能测试工具

通过系统性地学习和实践这些错误处理技巧，可以大大提高 Next.js 应用的稳定性和可维护性。
