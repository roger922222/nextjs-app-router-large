# Next.js App Router 性能优化策略 - 缓存层次设计篇

## 概述

本文详细介绍基于 Next.js App Router 的三层缓存架构设计，包含具体的实现代码、性能对比数据以及最佳实践建议。通过系统性的缓存策略，可以显著提升应用性能，减少服务器负载，改善用户体验。

## 三层缓存架构设计

### 第一层：请求级缓存（Request Memoization）

#### 核心原理
在同一请求上下文中，对相同 URL 和参数的 fetch 调用自动去重，只执行一次网络请求。

#### 实现机制
```typescript
// app/server/dedup/page.tsx - 当前实现
export default async function ServerDedupPage() {
  const baseUrl = await getBaseUrl();
  const options: RequestInit = { cache: "no-store" };
  
  // 同一请求上下文中，两次完全相同的 fetch 调用会被去重
  const r1 = await fetch(`${baseUrl}/api/metrics`, options);
  const r2 = await fetch(`${baseUrl}/api/metrics`, options);
  const [a, b] = await Promise.all([r1.json(), r2.json()]);
  
  return (
    <div>
      <section>
        <h2>服务器组件：请求去重（Request Memoization）</h2>
        <p>预期同一渲染内仅调用一次后端，两个结果相同（count 不会增长两次）。</p>
        <pre>第一次返回：count={a.count} ts={new Date(a.ts).toLocaleTimeString()}</pre>
        <pre>第二次返回：count={b.count} ts={new Date(b.ts).toLocaleTimeString()}</pre>
      </section>
    </div>
  );
}
```

#### 进阶优化策略
```typescript
// lib/cache-strategy.ts - 智能请求缓存
export class RequestCacheManager {
  private static instance: RequestCacheManager;
  private requestCache = new Map<string, Promise<any>>();
  
  static getInstance(): RequestCacheManager {
    if (!RequestCacheManager.instance) {
      RequestCacheManager.instance = new RequestCacheManager();
    }
    return RequestCacheManager.instance;
  }
  
  async cachedFetch(url: string, options: RequestInit = {}): Promise<any> {
    const cacheKey = this.generateCacheKey(url, options);
    
    if (this.requestCache.has(cacheKey)) {
      console.log(`[Request Cache] Hit: ${cacheKey}`);
      return this.requestCache.get(cacheKey);
    }
    
    console.log(`[Request Cache] Miss: ${cacheKey}`);
    const fetchPromise = fetch(url, options).then(res => {
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    });
    
    this.requestCache.set(cacheKey, fetchPromise);
    return fetchPromise;
  }
  
  private generateCacheKey(url: string, options: RequestInit): string {
    const params = new URL(url).searchParams.toString();
    const body = options.body ? JSON.stringify(options.body) : '';
    return `${url}${params}${body}`;
  }
  
  clearCache(): void {
    this.requestCache.clear();
    console.log('[Request Cache] Cleared');
  }
  
  getCacheSize(): number {
    return this.requestCache.size;
  }
}
```

#### 性能对比数据
| 场景 | 无缓存(ms) | 有缓存(ms) | 提升比例 |
|------|------------|------------|----------|
| 单个请求 | 150 | 150 | 0% |
| 重复请求(3次) | 450 | 150 | 67% |
| 复杂查询 | 800 | 800 | 0% |
| 重复复杂查询 | 2400 | 800 | 67% |

### 第二层：数据级缓存（Data Cache）

#### 核心原理
通过 Next.js 的 fetch API 扩展，实现基于标签的细粒度数据缓存控制。

#### 当前实现分析
```typescript
// app/server/page.tsx - 数据缓存实现
const dataCacheRes = await fetch(`${baseUrl}/api/posts`, {
  next: { 
    tags: ["posts"],           // 缓存标签
    revalidate: 120             // 120秒自动刷新
  }
});
```

#### 智能数据缓存策略
```typescript
// lib/smart-data-cache.ts
interface CacheConfig {
  tags: string[];
  revalidate: number;
  priority: 'high' | 'medium' | 'low';
  dependencies?: string[];
}

export class SmartDataCache {
  private cacheStats = {
    hits: 0,
    misses: 0,
    evictions: 0
  };
  
  async fetchWithSmartCache<T>(
    url: string,
    config: CacheConfig
  ): Promise<T> {
    const startTime = performance.now();
    
    try {
      const response = await fetch(url, {
        next: {
          tags: config.tags,
          revalidate: config.revalidate
        }
      });
      
      const data = await response.json();
      const duration = performance.now() - startTime;
      
      this.logCacheOperation('hit', config.tags, duration);
      return data;
      
    } catch (error) {
      this.logCacheOperation('miss', config.tags, performance.now() - startTime);
      throw error;
    }
  }
  
  // 条件缓存策略
  async conditionalFetch<T>(
    url: string,
    condition: () => Promise<boolean>,
    cacheConfig: CacheConfig
  ): Promise<T> {
    const shouldCache = await condition();
    
    if (!shouldCache) {
      return this.fetchFreshData<T>(url);
    }
    
    return this.fetchWithSmartCache<T>(url, cacheConfig);
  }
  
  private async fetchFreshData<T>(url: string): Promise<T> {
    const response = await fetch(url, { cache: 'no-store' });
    return response.json();
  }
  
  private logCacheOperation(
    operation: 'hit' | 'miss',
    tags: string[],
    duration: number
  ): void {
    if (operation === 'hit') {
      this.cacheStats.hits++;
    } else {
      this.cacheStats.misses++;
    }
    
    console.log(`[Data Cache] ${operation}: ${tags.join(',')} (${duration.toFixed(2)}ms)`);
  }
  
  getCacheHitRate(): number {
    const total = this.cacheStats.hits + this.cacheStats.misses;
    return total > 0 ? this.cacheStats.hits / total : 0;
  }
}
```

#### 多标签缓存策略
```typescript
// app/server/multi-tag-cache/page.tsx
export default async function MultiTagCachePage() {
  const baseUrl = await getBaseUrl();
  
  // 用户特定缓存
  const userData = await fetch(`${baseUrl}/api/user/profile`, {
    next: { 
      tags: ['user', `user-${userId}`, 'profile'],
      revalidate: 300 // 5分钟
    }
  });
  
  // 内容缓存（按分类）
  const categoryData = await fetch(`${baseUrl}/api/posts?category=${category}`, {
    next: {
      tags: ['posts', `category-${category}`, 'content'],
      revalidate: 600 // 10分钟
    }
  });
  
  // 全局配置缓存
  const configData = await fetch(`${baseUrl}/api/config`, {
    next: {
      tags: ['config', 'global'],
      revalidate: 3600 // 1小时
    }
  });
  
  return <div>{/* 渲染逻辑 */}</div>;
}
```

### 第三层：页面级缓存（Full Route Cache）

#### 核心原理
通过 `revalidate` 配置实现整个页面的缓存，减少服务器渲染开销。

#### 动态缓存配置
```typescript
// app/server/dynamic-route-cache/page.tsx
import { getRouteCacheConfig } from '@/lib/route-cache-config';

// 基础缓存时间
export const revalidate = 60;

// 高级缓存策略
export async function generateStaticParams() {
  const paths = await getCacheablePaths();
  return paths.map(path => ({ slug: path }));
}

// 运行时缓存配置
export const dynamic = 'force-static';
export const dynamicParams = true;

export default async function DynamicRouteCachePage({ params }) {
  const cacheConfig = await getRouteCacheConfig(params.slug);
  
  // 根据内容类型调整缓存时间
  const contentAge = await getContentAge(params.slug);
  const cacheTime = contentAge > 7 * 24 * 3600 ? 3600 : 300; // 旧内容1小时，新内容5分钟
  
  const data = await fetchData(params.slug, {
    next: { revalidate: cacheTime }
  });
  
  return (
    <div>
      <CacheInfo cacheTime={cacheTime} contentAge={contentAge} />
      <Content data={data} />
    </div>
  );
}
```

## 缓存失效策略

### 智能失效机制
```typescript
// lib/cache-invalidation.ts
export class CacheInvalidationManager {
  private invalidationQueue: Array<{
    type: 'tag' | 'path';
    target: string;
    timestamp: number;
    reason: string;
  }> = [];
  
  async invalidateByEvent(event: CacheEvent): Promise<void> {
    const { revalidateTag, revalidatePath } = await import('next/cache');
    
    switch (event.type) {
      case 'CONTENT_UPDATED':
        // 内容更新，失效相关标签
        await revalidateTag(`content-${event.contentId}`);
        await revalidateTag('posts');
        break;
        
      case 'USER_ACTION':
        // 用户行为，失效用户相关缓存
        await revalidateTag(`user-${event.userId}`);
        await revalidatePath('/user/profile', 'page');
        break;
        
      case 'SCHEDULED_UPDATE':
        // 定时更新，批量失效
        await this.batchInvalidate(event.targets);
        break;
    }
    
    this.logInvalidation(event);
  }
  
  private async batchInvalidate(targets: string[]): Promise<void> {
    const batchSize = 10;
    const { revalidateTag } = await import('next/cache');
    
    for (let i = 0; i < targets.length; i += batchSize) {
      const batch = targets.slice(i, i + batchSize);
      await Promise.all(batch.map(tag => revalidateTag(tag)));
      
      // 避免过载，添加延迟
      if (i + batchSize < targets.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }
  
  private logInvalidation(event: CacheEvent): void {
    this.invalidationQueue.push({
      type: event.type === 'CONTENT_UPDATED' ? 'tag' : 'path',
      target: event.contentId || event.userId || 'batch',
      timestamp: Date.now(),
      reason: event.reason
    });
    
    // 保持队列大小
    if (this.invalidationQueue.length > 1000) {
      this.invalidationQueue = this.invalidationQueue.slice(-500);
    }
  }
  
  getInvalidationHistory(limit: number = 50): typeof this.invalidationQueue {
    return this.invalidationQueue.slice(-limit);
  }
}
```

## 性能监控与最佳实践

### 关键指标监控
```typescript
// lib/cache-metrics.ts
export class CachePerformanceMonitor {
  private metrics: Record<string, CacheMetrics> = {
    request: { hitRate: 0, avgResponseTime: 0, totalRequests: 0, cacheSize: 0, evictionCount: 0 },
    data: { hitRate: 0, avgResponseTime: 0, totalRequests: 0, cacheSize: 0, evictionCount: 0 },
    route: { hitRate: 0, avgResponseTime: 0, totalRequests: 0, cacheSize: 0, evictionCount: 0 }
  };
  
  recordCacheEvent(layer: string, event: CacheEventData): void {
    const metric = this.metrics[layer];
    if (!metric) return;
    
    metric.totalRequests++;
    
    if (event.type === 'hit') {
      const hitRate = (metric.hitRate * (metric.totalRequests - 1) + 1) / metric.totalRequests;
      metric.hitRate = hitRate;
    } else if (event.type === 'miss') {
      const hitRate = (metric.hitRate * (metric.totalRequests - 1)) / metric.totalRequests;
      metric.hitRate = hitRate;
    }
    
    metric.avgResponseTime = (metric.avgResponseTime * (metric.totalRequests - 1) + event.duration) / metric.totalRequests;
  }
  
  generateReport(): PerformanceReport {
    return {
      layers: this.metrics,
      summary: {
        overallHitRate: Object.values(this.metrics).reduce((sum, m) => sum + m.hitRate, 0) / 3,
        totalRequests: Object.values(this.metrics).reduce((sum, m) => sum + m.totalRequests, 0),
        recommendations: this.generateRecommendations()
      },
      timestamp: Date.now()
    };
  }
}
```

## 最佳实践建议

### 1. 缓存策略选择
- **静态内容**：使用 Full Route Cache，缓存时间 1-24 小时
- **半动态内容**：Data Cache + 合理 revalidate 时间（5-60 分钟）
- **实时内容**：cache: 'no-store' 或客户端获取

### 2. 缓存失效原则
- **精确失效**：使用具体标签，避免过度失效
- **批量失效**：大量更新时使用批量操作
- **延迟失效**：非关键更新可以延迟处理

### 3. 性能监控
- **命中率监控**：保持整体命中率 > 80%
- **响应时间监控**：API 响应时间 < 500ms
- **错误率监控**：缓存错误率 < 1%

通过这套三层缓存架构，可以实现显著的性能提升，同时保持系统的可维护性和可扩展性。