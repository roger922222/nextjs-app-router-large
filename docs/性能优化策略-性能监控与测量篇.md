# Next.js App Router 性能优化策略 - 性能监控与测量篇

## 概述

性能监控与测量是持续优化的基础。本文详细介绍基于 Next.js App Router 的全链路性能监控方案，包括 Web Vitals 监控、API 性能分析、用户体验指标收集等，通过数据驱动的优化策略，实现可量化的性能提升。

## Web Vitals 监控

### 1. 核心 Web 指标收集

#### 基础 Web Vitals 监控
```typescript
// lib/web-vitals-monitor.ts
export class WebVitalsMonitor {
  private metrics: Record<string, number[]> = {
    FCP: [],  // First Contentful Paint
    LCP: [],  // Largest Contentful Paint  
    CLS: [],  // Cumulative Layout Shift
    FID: [],  // First Input Delay
    TTFB: [], // Time to First Byte
    INP: []   // Interaction to Next Paint
  };
  
  private thresholds = {
    FCP: { good: 1800, needsImprovement: 3000 },
    LCP: { good: 2500, needsImprovement: 4000 },
    CLS: { good: 0.1, needsImprovement: 0.25 },
    FID: { good: 100, needsImprovement: 300 },
    TTFB: { good: 800, needsImprovement: 1800 },
    INP: { good: 200, needsImprovement: 500 }
  };
  
  // 初始化 Web Vitals 监控
  initialize(): void {
    if (typeof window === 'undefined') return;
    
    import('web-vitals').then(({ 
      getCLS, 
      getFID, 
      getFCP, 
      getLCP, 
      getTTFB,
      onINP 
    }) => {
      getCLS(this.handleMetric.bind(this, 'CLS'));
      getFID(this.handleMetric.bind(this, 'FID'));
      getFCP(this.handleMetric.bind(this, 'FCP'));
      getLCP(this.handleMetric.bind(this, 'LCP'));
      getTTFB(this.handleMetric.bind(this, 'TTFB'));
      onINP(this.handleMetric.bind(this, 'INP'));
    });
  }
  
  private handleMetric(metricName: string, metric: any): void {
    const value = Math.round(metric.value * 100) / 100;
    
    // 存储指标
    this.metrics[metricName].push(value);
    
    // 保持数组大小
    if (this.metrics[metricName].length > 100) {
      this.metrics[metricName].shift();
    }
    
    // 分类指标等级
    const rating = this.getRating(metricName, value);
    
    // 发送到分析服务
    this.sendToAnalytics(metricName, value, rating, metric);
    
    // 控制台输出（开发环境）
    if (process.env.NODE_ENV === 'development') {
      console.log(`[Web Vitals] ${metricName}: ${value}ms (${rating})`);
    }
  }
  
  private getRating(metricName: string, value: number): 'good' | 'needs-improvement' | 'poor' {
    const threshold = this.thresholds[metricName];
    if (!threshold) return 'needs-improvement';
    
    if (value <= threshold.good) return 'good';
    if (value <= threshold.needsImprovement) return 'needs-improvement';
    return 'poor';
  }
  
  private sendToAnalytics(
    metricName: string, 
    value: number, 
    rating: string, 
    metric: any
  ): void {
    // Google Analytics
    if (typeof window !== 'undefined' && (window as any).gtag) {
      (window as any).gtag('event', metricName, {
        value: Math.round(value),
        metric_rating: rating,
        metric_delta: metric.delta,
        metric_id: metric.id,
        metric_navigation_type: metric.navigationType
      });
    }
    
    // 自定义分析服务
    this.sendToCustomAnalytics(metricName, value, rating, metric);
  }
  
  private sendToCustomAnalytics(
    metricName: string,
    value: number,
    rating: string,
    metric: any
  ): void {
    // 发送到自定义分析端点
    fetch('/api/analytics/web-vitals', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        metric: metricName,
        value,
        rating,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
        navigationType: metric.navigationType,
        delta: metric.delta
      })
    }).catch(console.error);
  }
  
  // 获取指标统计
  getStats(metricName?: string): WebVitalsStats {
    if (metricName) {
      return this.calculateStats(this.metrics[metricName] || []);
    }
    
    const allStats: Record<string, WebVitalsStats> = {};
    for (const [name, values] of Object.entries(this.metrics)) {
      allStats[name] = this.calculateStats(values);
    }
    
    return allStats;
  }
  
  private calculateStats(values: number[]): WebVitalsStats {
    if (values.length === 0) {
      return { avg: 0, min: 0, max: 0, p75: 0, p95: 0, count: 0 };
    }
    
    const sorted = [...values].sort((a, b) => a - b);
    const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
    
    return {
      avg: Math.round(avg * 100) / 100,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p75: this.percentile(sorted, 0.75),
      p95: this.percentile(sorted, 0.95),
      count: values.length
    };
  }
  
  private percentile(sorted: number[], p: number): number {
    const index = Math.ceil(sorted.length * p) - 1;
    return sorted[Math.max(0, index)];
  }
  
  // 生成性能报告
  generateReport(): WebVitalsReport {
    const stats = this.getStats() as Record<string, WebVitalsStats>;
    const recommendations = this.generateRecommendations(stats);
    
    return {
      stats,
      summary: {
        overallScore: this.calculateOverallScore(stats),
        issuesCount: recommendations.length,
        lastUpdated: Date.now()
      },
      recommendations,
      timestamp: Date.now()
    };
  }
  
  private calculateOverallScore(stats: Record<string, WebVitalsStats>): number {
    const scores = Object.entries(stats).map(([name, stat]) => {
      const threshold = this.thresholds[name];
      if (!threshold) return 50;
      
      if (stat.avg <= threshold.good) return 100;
      if (stat.avg <= threshold.needsImprovement) return 75;
      return 25;
    });
    
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
  }
  
  private generateRecommendations(stats: Record<string, WebVitalsStats>): string[] {
    const recommendations: string[] = [];
    
    for (const [metricName, stat] of Object.entries(stats)) {
      const rating = this.getRating(metricName, stat.avg);
      
      if (rating === 'poor') {
        recommendations.push(this.getPoorRecommendation(metricName));
      } else if (rating === 'needs-improvement') {
        recommendations.push(this.getNeedsImprovementRecommendation(metricName));
      }
    }
    
    return recommendations;
  }
  
  private getPoorRecommendation(metricName: string): string {
    const recommendations: Record<string, string> = {
      LCP: '优化 Largest Contentful Paint：压缩图片、使用 CDN、优化关键渲染路径',
      FCP: '改善 First Contentful Paint：减少服务器响应时间、优化 CSS 和 JavaScript 加载',
      CLS: '减少 Cumulative Layout Shift：为图片和广告预留空间、避免动态插入内容',
      FID: '优化 First Input Delay：分解长任务、减少 JavaScript 执行时间',
      TTFB: '提升 Time to First Byte：使用 CDN、优化服务器性能、启用缓存',
      INP: '改善 Interaction to Next Paint：优化事件处理、减少主线程阻塞'
    };
    
    return recommendations[metricName] || `${metricName} 需要优化`;
  }
  
  private getNeedsImprovementRecommendation(metricName: string): string {
    return `${metricName} 有改善空间，建议进一步优化`;
  }
}

// 类型定义
interface WebVitalsStats {
  avg: number;
  min: number;
  max: number;
  p75: number;
  p95: number;
  count: number;
}

interface WebVitalsReport {
  stats: Record<string, WebVitalsStats>;
  summary: {
    overallScore: number;
    issuesCount: number;
    lastUpdated: number;
  };
  recommendations: string[];
  timestamp: number;
}
```

## 性能监控仪表板

### 1. 实时性能监控组件
```typescript
// components/PerformanceDashboard.tsx
import { useEffect, useState } from 'react';

interface PerformanceMetrics {
  webVitals: Record<string, WebVitalsStats>;
  apiPerformance: APIPerformanceStats;
  cacheMetrics: CacheMetrics;
  userExperience: UserExperienceMetrics;
}

export function PerformanceDashboard({ 
  autoRefresh = true,
  refreshInterval = 30000 
}: {
  autoRefresh?: boolean;
  refreshInterval?: number;
}) {
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
  
  // 获取性能数据
  const fetchMetrics = async () => {
    try {
      const response = await fetch('/api/performance/metrics');
      const data = await response.json();
      setMetrics(data);
      setLastUpdate(new Date());
    } catch (error) {
      console.error('Failed to fetch performance metrics:', error);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchMetrics();
    
    if (autoRefresh) {
      const interval = setInterval(fetchMetrics, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [autoRefresh, refreshInterval]);
  
  if (loading) {
    return <PerformanceDashboardSkeleton />;
  }
  
  if (!metrics) {
    return <PerformanceDashboardError onRetry={fetchMetrics} />;
  }
  
  return (
    <div className="performance-dashboard">
      <div className="dashboard-header">
        <h2>性能监控仪表板</h2>
        <div className="dashboard-controls">
          <span className="last-update">
            最后更新: {lastUpdate?.toLocaleTimeString()}
          </span>
          <button onClick={fetchMetrics} className="refresh-button">
            刷新
          </button>
        </div>
      </div>
      
      <div className="dashboard-grid">
        <WebVitalsCard metrics={metrics.webVitals} />
        <APIPerformanceCard stats={metrics.apiPerformance} />
        <CacheMetricsCard metrics={metrics.cacheMetrics} />
        <UserExperienceCard metrics={metrics.userExperience} />
      </div>
      
      <div className="dashboard-recommendations">
        <PerformanceRecommendations metrics={metrics} />
      </div>
    </div>
  );
}

// Web Vitals 卡片组件
function WebVitalsCard({ metrics }: { metrics: Record<string, WebVitalsStats> }) {
  return (
    <div className="metric-card">
      <h3>Web Vitals</h3>
      <div className="vitals-grid">
        {Object.entries(metrics).map(([name, stat]) => (
          <div key={name} className="vital-item">
            <div className="vital-name">{name}</div>
            <div className="vital-value">{stat.avg}ms</div>
            <div className="vital-rating">
              <RatingIndicator value={stat.avg} metric={name} />
            </div>
            <div className="vital-stats">
              <span>p75: {stat.p75}ms</span>
              <span>p95: {stat.p95}ms</span>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// API 性能卡片组件
function APIPerformanceCard({ stats }: { stats: APIPerformanceStats }) {
  return (
    <div className="metric-card">
      <h3>API 性能</h3>
      <div className="api-stats">
        <div className="stat-item">
          <span className="stat-label">平均响应时间</span>
          <span className="stat-value">{stats.avgResponseTime}ms</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">请求成功率</span>
          <span className="stat-value">{(stats.successRate * 100).toFixed(1)}%</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">缓存命中率</span>
          <span className="stat-value">{(stats.cacheHitRate * 100).toFixed(1)}%</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">总请求数</span>
          <span className="stat-value">{stats.totalRequests}</span>
        </div>
      </div>
    </div>
  );
}

// 评分指示器组件
function RatingIndicator({ value, metric }: { value: number; metric: string }) {
  const getRating = (metric: string, value: number) => {
    // 根据指标类型和值返回评分
    const thresholds: Record<string, { good: number; poor: number }> = {
      LCP: { good: 2500, poor: 4000 },
      FCP: { good: 1800, poor: 3000 },
      CLS: { good: 0.1, poor: 0.25 },
      FID: { good: 100, poor: 300 },
      TTFB: { good: 800, poor: 1800 }
    };
    
    const threshold = thresholds[metric];
    if (!threshold) return 'unknown';
    
    if (value <= threshold.good) return 'good';
    if (value <= threshold.poor) return 'needs-improvement';
    return 'poor';
  };
  
  const rating = getRating(metric, value);
  const ratingClass = `rating-${rating}`;
  
  return <span className={`rating-indicator ${ratingClass}`}>{rating}</span>;
}
```

## 性能优化建议

### 1. 监控指标设置
- **核心指标**: LCP < 2.5s, FID < 100ms, CLS < 0.1
- **业务指标**: API 响应时间 < 500ms, 缓存命中率 > 80%
- **用户体验**: 页面加载完成率 > 95%, 错误率 < 1%

### 2. 告警机制
- **性能告警**: 关键指标超过阈值时发送告警
- **错误告警**: 错误率异常时立即告警
- **趋势告警**: 性能持续下降时预警

### 3. 报告生成
- **日报**: 每日性能指标汇总
- **周报**: 周性能趋势分析
- **月报**: 月度性能优化建议

通过这套完整的性能监控与测量体系，可以实现数据驱动的性能优化，持续提升应用性能和用户体验。